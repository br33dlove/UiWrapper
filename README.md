# UiWrapper
Library to provide wrapping of Android Fragments to smooth out lifecycles and provide view framework for MVP architectures on Android platform

The aim of this library is to provide a framework which supports a more modular design of Android applications. It lends a particular structure to an application, where interactions with back-end services are kept away from UI implementations by using UiWrapper-derived classes, and defines set responsibilities to fragments and activities. Fragments must extend the UiFragment abstract class and are responsible for the UI implementation. Activities must extend UiWrapperRepositoryActivity (or it's subclass SingleContentContainerWithAppBarActivity) and are responsible for providing the app bar and view containers in which to attach the fragments, as well as navigation (adding/removing fragments and starting new activities). This way, the UI and business logic is moved away from the Android API. Ideally, the UiWrapper subclasses are used to implement the View interface in an MVP architecture, where the Presenter is created in the UiWrapper's constructor, with the Presenter handling communication with back-end services/the Model component and controlling the high-level UI logic, in order to complete the separation of the Android API from the UI and business logic.

UiWrapper subclasses provide a layer of abstraction above UI-implementations (fragments, activities) and also act to smooth out fragment and activity lifecycles by persisting across configuration changes and as such Ui objects are bound-to and unbound-from the UiWrapper. As they are created by the developer, dependencies can be injected into the UiWrappers via the constructor. Injected service objects can then requests started in the registerResources() method, and requests stopped in the unregisterResources() method, which are called by the UiWrapper superclass when binding and unbinding respectively. This means that your service objects can be injected where necessary and not exist as globally-accessible singletons. In the case of MVP, these service-objects would instead be injected into the presenter, and the register and unregister methods would simply be passed on.

//UiWrapper class and UiModel
